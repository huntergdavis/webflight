<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Superflight (clean-room) — Daylight Mountain Glide</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:linear-gradient(#a7d3ff,#eaf6ff); font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    #app { position:fixed; inset:0; overflow:hidden; }
    .hud { position:absolute; top:8px; left:8px; color:#003; background:rgba(255,255,255,.6); padding:8px 10px; border-radius:12px; font-size:13px; line-height:1.15; backdrop-filter:saturate(1.2) blur(2px); }
    .ret { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); color:#000; opacity:.35; pointer-events:none; }
    .ret div { background:rgba(0,0,0,.7); border-radius:2px; margin:auto; }
    .ret .v { width:4px; height:20px; }
    .ret .h { width:20px; height:4px; margin-top:4px; }
    .help { position:absolute; right:8px; top:8px; color:#003; background:rgba(255,255,255,.6); padding:8px 10px; border-radius:12px; font-size:12px; max-width:300px; backdrop-filter:saturate(1.2) blur(2px); }
    .overlay { position:absolute; inset:0; display:none; place-items:center; color:#fff; }
    .overlay .box { background:rgba(0,0,0,.55); padding:16px 20px; border-radius:18px; text-align:center; }
    .foot { position:absolute; left:50%; bottom:8px; transform:translateX(-50%); color:#003; font-size:11px; background:rgba(255,255,255,.6); padding:4px 8px; border-radius:999px; opacity:.9; }
  </style>
</head>
<body>
<div id="app"></div>

<div class="hud">
  <div><b>Score:</b> <span id="uiScore">0</span></div>
  <div>× <b>Mult:</b> <span id="uiMult">1.0</span></div>
  <div><b>Speed:</b> <span id="uiSpeed">0</span></div>
  <div><b>Seed:</b> <span id="uiSeed">0</span></div>
  <div><b>Diff:</b> <span id="uiDiff">1</span></div>
</div>

<div class="ret"><div class="v"></div><div class="h"></div></div>

<div class="help">
  <div style="font-weight:600;margin-bottom:4px">Controls</div>
  <div>W/S or ↑/↓: pitch (W = nose down, S = nose up)</div>
  <div>A/D or ←/→: yaw (A = left, D = right)</div>
  <div>Q/E: roll</div>
  <div>P: pause · R: restart</div>
</div>

<div id="crash" class="overlay" style="background:rgba(177,0,0,.35);">
  <div class="box">
    <div style="font-size:24px;font-weight:800;letter-spacing:.04em;">CRASHED</div>
    <div style="opacity:.85;margin-top:6px;font-size:13px;">Press R to restart</div>
    <div style="opacity:.75;margin-top:10px;font-size:12px;">High Score: <span id="uiHi">0</span></div>
  </div>
</div>

<div id="paused" class="overlay" style="background:rgba(0,0,0,.35);">
  <div class="box">
    <div style="font-size:18px;font-weight:800;letter-spacing:.04em;">PAUSED</div>
    <div style="opacity:.85;margin-top:6px;font-size:13px;">Press P to resume</div>
  </div>
</div>

<div class="foot">Daylight sky · Cloud layer · Mountain range (no caves) · Glide physics</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

////////////////////////////// utils
function mulberry32(seed){ let t=seed>>>0; return ()=>{ t+=0x6D2B79F5; let r=Math.imul(t^(t>>>15),1|t); r^=r+Math.imul(r^(r>>>7),61|r); return ((r^(r>>>14))>>>0)/4294967296; }; }
const randRange=(rng,a,b)=>a+(b-a)*rng();
const choose=(rng,arr)=>arr[Math.floor(rng()*arr.length)];
const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
const smooth=(t)=>t*t*(3-2*t); // smoothstep

// seeded 2D value noise
function makeNoise2D(seed){
  function hash(i,j){
    let h = (i|0)*374761393 + (j|0)*668265263 + (seed|0)*1442695040888963407n; // big mix (use BigInt then cast)
    // JS BigInt -> number safe mix:
    h = Number((BigInt(h) ^ (BigInt(h)>>13n)) & 0xffffffffn);
    h = (h ^ (h>>>17)) * 2246822519;
    h = (h ^ (h>>>15)) >>> 0;
    return h / 4294967295;
  }
  return (x,z)=>{
    const ix=Math.floor(x), iz=Math.floor(z);
    const fx=x-ix, fz=z-iz;
    const u=smooth(fx), v=smooth(fz);
    const n00=hash(ix,iz),   n10=hash(ix+1,iz);
    const n01=hash(ix,iz+1), n11=hash(ix+1,iz+1);
    const nx0=n00+(n10-n00)*u, nx1=n01+(n11-n01)*u;
    return nx0+(nx1-nx0)*v;
  };
}

// fBm
function makeFBM(noise){ 
  return (x,z,oct=5,pers=0.5,lacun=2)=>{ 
    let f=1,a=1,acc=0,sum=0;
    for(let o=0;o<oct;o++){ acc+=a*noise(x*f,z*f); sum+=a; f*=lacun; a*=pers; }
    return acc/sum;
  };
}

// Ridged
function ridged(n){ return 1 - Math.abs(2*n - 1); }

////////////////////////////// DOM
const app = document.getElementById('app');
const uiScore = document.getElementById('uiScore');
const uiMult  = document.getElementById('uiMult');
const uiSpeed = document.getElementById('uiSpeed');
const uiSeed  = document.getElementById('uiSeed');
const uiDiff  = document.getElementById('uiDiff');
const crashEl = document.getElementById('crash');
const pausedEl= document.getElementById('paused');

////////////////////////////// three setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 6000);
camera.position.set(0, 280, 220);

const fogColor = new THREE.Color('#cfeaff');
scene.fog = new THREE.Fog(fogColor, 120, 2600);

const hemi = new THREE.HemisphereLight(0xcfeaff, 0xbfa17a, 0.9); // bright sky, warm ground
hemi.position.set(0,400,0); scene.add(hemi);
const dir  = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(-120,200,80); dir.castShadow=false; scene.add(dir);
const amb  = new THREE.AmbientLight(0xffffff, 0.25); scene.add(amb);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
app.appendChild(renderer.domElement);

////////////////////////////// state
const inputs = { w:false,s:false,a:false,d:false,q:false,e:false };
let terrain = null; // set later
let clouds = null;
let portalMesh = null;

const state = {
  playerPos: new THREE.Vector3(0,280,220),
  playerQuat: new THREE.Quaternion().multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), THREE.MathUtils.degToRad(12))), // slight nose-down
  playerRadius: 1.0,
  vel: new THREE.Vector3(0,-10,-20),

  gravity: 9.5,       // ↓ less gravity → more glide
  glideAccel: 26,     // thrust along forward
  drag: 0.42,         // gentle drag
  maxSpeed: 110,

  yawRate:   THREE.MathUtils.degToRad(90),
  pitchRate: THREE.MathUtils.degToRad(70),
  rollRate:  THREE.MathUtils.degToRad(140),

  score: 0, multiplier: 1, maxMultiplier: 12, proxThreshold: 8.0,
  crashed:false, paused:false,
  worldSeed: Math.floor(Math.random()*1e9), difficulty:1,
  highScore:0,
};

////////////////////////////// glider
function buildGlider(){
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.ConeGeometry(0.5,1.8,6), new THREE.MeshStandardMaterial({color:0xffffff, roughness:.4, metalness:.1}));
  body.rotation.x = Math.PI/2; g.add(body);
  const wing = new THREE.Mesh(new THREE.BoxGeometry(3.2, .08, .6), new THREE.MeshStandardMaterial({color:0x87ceeb, roughness:.6}));
  wing.position.set(0,0,-.1); g.add(wing);
  const tail = new THREE.Mesh(new THREE.BoxGeometry(.9,.06,.5), new THREE.MeshStandardMaterial({color:0x87ceeb, roughness:.6}));
  tail.position.set(0,-.2,.4); tail.rotation.z = THREE.MathUtils.degToRad(15); g.add(tail);
  return g;
}
const glider = buildGlider(); scene.add(glider);

////////////////////////////// terrain gen (heightmap, no caves)
function buildTerrain(seed){
  const rng = mulberry32(seed);
  const theme = {
    rockLo: new THREE.Color('#d49a6a'), // sand/rock
    rockHi: new THREE.Color('#8d6442'), // darker strata
    grass:  new THREE.Color('#9ecb7a'),
    snow:   new THREE.Color('#f5f7fb')
  };

  const params = {
    width: 900,
    length: 5200,
    segX: 160,
    segZ: 420,
    amp: 95,
    base: -20,
    slope: 0.04,     // gentle overall descent toward -Z
    nx: 0.0022,      // noise scale X
    nz: 0.0022,
    ridgeMix: 0.55,  // blend fbm/ridge
  };

  const noise = makeNoise2D(seed ^ 0x9e3779b9);
  const fbm   = makeFBM(noise);

  // height function mirrors the mesh deformation for accurate collision
  function heightAt(x,z){
    // Normalize to noise space
    const n1 = fbm(x*params.nx, z*params.nz, 5, 0.55, 2.1);
    const n2 = ridged(fbm(x*params.nx*0.45, z*params.nz*0.45, 4, 0.5, 2.0));
    const shape = (1-params.ridgeMix)*n1 + params.ridgeMix*n2; // 0..1
    const slopeTerm = (-(z + params.length*0.35) / params.length) * params.slope * params.amp; // down as z decreases
    return params.base + shape*params.amp + slopeTerm;
  }

  // geometry
  const geo = new THREE.PlaneGeometry(params.width, params.length, params.segX, params.segZ);
  geo.rotateX(-Math.PI/2);
  const pos = geo.attributes.position;
  const colors = new Float32Array((params.segX+1)*(params.segZ+1)*3);

  let i=0;
  for(let v=0; v<pos.count; v++){
    const x = pos.getX(v), z = pos.getZ(v);
    const y = heightAt(x,z);
    pos.setY(v, y);

    // vertex color by altitude
    const t = clamp((y - (params.base-20)) / (params.amp+40), 0, 1);
    let c = new THREE.Color();
    if (t < 0.45) c.lerpColors(theme.rockLo, theme.rockHi, t/0.45);
    else if (t < 0.80) c.lerpColors(theme.rockHi, theme.grass, (t-0.45)/0.35);
    else c.lerpColors(theme.grass, theme.snow, (t-0.80)/0.20);
    colors[i++]=c.r; colors[i++]=c.g; colors[i++]=c.b;
  }
  geo.setAttribute('color', new THREE.BufferAttribute(colors,3));
  geo.computeVertexNormals();

  const mat = new THREE.MeshStandardMaterial({ vertexColors:true, flatShading:false, roughness:0.95, metalness:0.02 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.receiveShadow = false; mesh.castShadow = false;

  // clouds: billboards high above
  const cloudGroup = buildCloudLayer(seed, params);

  // portal near far end above a valley
  const portalZ = -params.length/2 + 140;
  const portalY = heightAt(0, portalZ) + 35;
  const ringR=12, ringT=1.8;
  const portalMat = new THREE.MeshStandardMaterial({ color: 0x7aa2ff, emissive: new THREE.Color(0x7aa2ff).multiplyScalar(.5), roughness:.2, metalness:0.0 });
  const portalMeshLocal = new THREE.Mesh(new THREE.TorusGeometry(ringR, ringT, 16, 44), portalMat);
  portalMeshLocal.position.set(0, portalY, portalZ);
  portalMeshLocal.userData.center = portalMeshLocal.position.clone();
  portalMeshLocal.userData.ringR = ringR;
  portalMeshLocal.userData.thickness = ringT;

  // pack everything
  const group = new THREE.Group();
  group.add(mesh);
  group.add(cloudGroup);
  group.add(portalMeshLocal);

  scene.add(group);

  return {
    group,
    params,
    heightAt,
    portal: portalMeshLocal
  };
}

// simple circular-gradient sprite texture
function makeCloudTexture(){
  const s=128, cnv=document.createElement('canvas'); cnv.width=cnv.height=s;
  const ctx=cnv.getContext('2d');
  const g=ctx.createRadialGradient(s/2,s/2,10, s/2,s/2,s/2);
  g.addColorStop(0,'rgba(255,255,255,0.9)');
  g.addColorStop(1,'rgba(255,255,255,0.0)');
  ctx.fillStyle=g; ctx.fillRect(0,0,s, s);
  const tex = new THREE.CanvasTexture(cnv); tex.anisotropy = 4; return tex;
}

function buildCloudLayer(seed, params){
  const rng = mulberry32(seed ^ 0xabcdef);
  const tex = makeCloudTexture();
  const grp = new THREE.Group();
  const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false });
  const count = 80;
  for(let i=0;i<count;i++){
    const sp = new THREE.Sprite(spriteMat.clone());
    sp.position.set(randRange(rng,-params.width*0.45, params.width*0.45), 320 + randRange(rng,-10,10), randRange(rng, -params.length*0.45, params.length*0.05));
    const s = randRange(rng, 60, 140);
    sp.scale.set(s, s, 1);
    sp.material.opacity = randRange(rng, 0.35, 0.75);
    grp.add(sp);
  }
  return grp;
}

////////////////////////////// build world
function disposeWorld(){
  if (!terrain) return;
  scene.remove(terrain.group);
  terrain.group.traverse(o=>{ if (o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); } if (o.isSprite){ o.material?.map?.dispose?.(); o.material?.dispose?.(); }});
  portalMesh = null;
  terrain = null;
}

function generateWorld(seed){
  disposeWorld();
  terrain = buildTerrain(seed);
  portalMesh = terrain.portal;
  uiSeed.textContent = seed;
  // start high & upstream
  state.playerPos.set(0, 280, 220);
  state.playerQuat.identity().multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), THREE.MathUtils.degToRad(12)));
  state.vel.set(0, -10, -20);
}

////////////////////////////// input
function setKey(e, down){
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  switch(e.code){
    case 'KeyW': case 'ArrowUp':    inputs.w = down; break; // W = nose down (plane feel)
    case 'KeyS': case 'ArrowDown':  inputs.s = down; break; // S = nose up
    case 'KeyA': case 'ArrowLeft':  inputs.a = down; break; // yaw left
    case 'KeyD': case 'ArrowRight': inputs.d = down; break; // yaw right
    case 'KeyQ': inputs.q = down; break;
    case 'KeyE': inputs.e = down; break;
    case 'KeyP': if(down) togglePause(); break;
    case 'KeyR': if(down) restart(); break;
  }
}
window.addEventListener('keydown', e=>setKey(e,true), {passive:false});
window.addEventListener('keyup',   e=>setKey(e,false), {passive:false});

////////////////////////////// game flow
function doCrash(){ state.crashed=true; crashEl.style.display='grid'; state.highScore = Math.max(state.highScore, state.score|0); document.getElementById('uiHi').textContent = state.highScore.toFixed(0); }
function togglePause(){ state.paused=!state.paused; pausedEl.style.display = state.paused ? 'grid' : 'none'; }
function restart(){
  state.playerPos.set(0, 280, 220);
  state.playerQuat.identity().multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), THREE.MathUtils.degToRad(12)));
  state.vel.set(0, -10, -20);
  state.score=0; state.multiplier=1; state.crashed=false;
  crashEl.style.display='none';
}
function nextWorld(){
  state.worldSeed = (state.worldSeed * 1664525 + 1013904223) >>> 0;
  state.difficulty += 1;
  generateWorld(state.worldSeed);
}

function resize(){
  const w=window.innerWidth, h=window.innerHeight;
  renderer.setSize(w,h);
  camera.aspect = w/h; camera.updateProjectionMatrix();
}
window.addEventListener('resize', resize);
resize();

generateWorld(state.worldSeed);

////////////////////////////// loop
function terrainDistanceBelow(pos){
  const yGround = terrain.heightAt(pos.x, pos.z);
  return pos.y - yGround;
}

const clock = new THREE.Clock();
renderer.setAnimationLoop(()=>{
  const dt = Math.min(0.05, clock.getDelta());
  if (state.paused || state.crashed) { renderer.render(scene,camera); return; }

  // controls → orientation (plane-like)
  const yaw   = ((inputs.a?1:0) - (inputs.d?1:0)) * state.yawRate   * dt; // D = right
  const pitch = ((inputs.s?1:0) - (inputs.w?1:0)) * state.pitchRate * dt; // W = nose down, S = up
  const roll  = ((inputs.q?1:0) - (inputs.e?1:0)) * state.rollRate  * dt; // Q left, E right

  const qYaw   = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),  yaw);
  const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),  pitch);
  const qRoll  = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -roll);
  state.playerQuat.multiply(qYaw).multiply(qPitch).multiply(qRoll).normalize();

  // forward & physics (glide)
  const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(state.playerQuat).normalize();
  const pitchDown = Math.max(0, -fwd.y);
  const thrust = (0.30 + pitchDown) * state.glideAccel;

  state.vel.addScaledVector(new THREE.Vector3(0,-1,0), state.gravity*dt);
  state.vel.addScaledVector(fwd, thrust*dt);

  const drag = 1 - Math.exp(-state.drag * dt); state.vel.multiplyScalar(1 - drag);
  const spd = state.vel.length(); if (spd > state.maxSpeed) state.vel.multiplyScalar(state.maxSpeed/spd);

  // small horizontal nudge so you keep moving
  const horiz = new THREE.Vector3(state.vel.x,0,state.vel.z); const hlen=horiz.length();
  if (hlen < 8){ const fH = new THREE.Vector3(fwd.x,0,fwd.z).normalize(); state.vel.addScaledVector(fH, (8 - hlen) * 0.35); }

  state.playerPos.addScaledVector(state.vel, dt);

  // camera
  const camOffLocal = new THREE.Vector3(0, 2.2, 9.0);
  const camPos = camOffLocal.clone().applyQuaternion(state.playerQuat).add(state.playerPos);
  camera.position.lerp(camPos, 0.2);
  camera.lookAt(state.playerPos.clone().add(fwd.clone().multiplyScalar(18)));

  // glider
  glider.position.copy(state.playerPos);
  glider.quaternion.copy(state.playerQuat);

  // ground collision/proximity
  const distBelow = terrainDistanceBelow(state.playerPos); // >0 if above ground
  const nearestDist = distBelow - state.playerRadius;
  if (nearestDist < 0) { doCrash(); renderer.render(scene,camera); return; }

  // scoring (closer to ground ⇒ more score)
  const closeness = clamp(1 - (nearestDist / state.proxThreshold), 0, 1);
  const gain = (4 + spd * 0.16) * state.multiplier * (0.25 + closeness * 1.4);
  state.score += gain * dt;
  if (closeness > 0.15) state.multiplier = Math.min(state.maxMultiplier, state.multiplier + dt * (0.15 + closeness * 0.45));
  else state.multiplier = Math.max(1, state.multiplier - dt * 1.2);

  // portal at far end
  if (portalMesh){
    const c = portalMesh.userData.center, ringR=portalMesh.userData.ringR, thick=portalMesh.userData.thickness;
    const dx=state.playerPos.x-c.x, dz=state.playerPos.z-c.z, dy=Math.abs(state.playerPos.y-c.y);
    const radial=Math.hypot(dx,dz);
    if (Math.abs(radial - ringR) < thick*0.7 && dy < thick*0.9) nextWorld();
  }

  // HUD
  uiScore.textContent = state.score.toFixed(0);
  uiMult.textContent  = state.multiplier.toFixed(1);
  uiSpeed.textContent = spd.toFixed(1);
  uiSeed.textContent  = state.worldSeed;
  uiDiff.textContent  = state.difficulty;

  renderer.render(scene, camera);
});
</script>
</body>
</html>

