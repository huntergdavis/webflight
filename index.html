<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Superflight (clean-room) — Aero Glide + Peakier Mountains</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:linear-gradient(#a7d3ff,#eaf6ff); font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    #app { position:fixed; inset:0; overflow:hidden; }
    .hud { position:absolute; top:8px; left:8px; color:#003; background:rgba(255,255,255,.6); padding:8px 10px; border-radius:12px; font-size:13px; line-height:1.15; backdrop-filter:saturate(1.2) blur(2px); }
    .ret { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); color:#000; opacity:.25; pointer-events:none; }
    .ret div { background:rgba(0,0,0,.6); border-radius:2px; margin:auto; }
    .ret .v { width:4px; height:20px; }
    .ret .h { width:20px; height:4px; margin-top:4px; }
    .help { position:absolute; right:8px; top:8px; color:#003; background:rgba(255,255,255,.6); padding:8px 10px; border-radius:12px; font-size:12px; max-width:340px; backdrop-filter:saturate(1.2) blur(2px); }
    .overlay { position:absolute; inset:0; display:none; place-items:center; color:#fff; }
    .overlay .box { background:rgba(0,0,0,.55); padding:16px 20px; border-radius:18px; text-align:center; }
    .foot { position:absolute; left:50%; bottom:8px; transform:translateX(-50%); color:#003; font-size:11px; background:rgba(255,255,255,.6); padding:4px 8px; border-radius:999px; opacity:.9; }
  </style>
</head>
<body>
<div id="app"></div>

<div class="hud">
  <div><b>Score:</b> <span id="uiScore">0</span></div>
  <div>× <b>Mult:</b> <span id="uiMult">1.0</span></div>
  <div><b>Speed:</b> <span id="uiSpeed">0</span></div>
  <div><b>Alt:</b> <span id="uiAlt">0</span> m</div>
  <div><b>Seed:</b> <span id="uiSeed">0</span></div>
  <div><b>Diff:</b> <span id="uiDiff">1</span></div>
</div>

<div class="ret"><div class="v"></div><div class="h"></div></div>

<div class="help">
  <div style="font-weight:600;margin-bottom:4px">Controls</div>
  <div>W/S or ↑/↓: pitch (W = nose down, S = nose up)</div>
  <div>A/D or ←/→: yaw (A = left, D = right)</div>
  <div>Q/E: roll</div>
  <div>P: pause · R: restart</div>
</div>

<div id="crash" class="overlay" style="background:rgba(177,0,0,.35);">
  <div class="box">
    <div style="font-size:24px;font-weight:800;letter-spacing:.04em;">CRASHED</div>
    <div style="opacity:.85;margin-top:6px;font-size:13px;">Press R to restart</div>
    <div style="opacity:.75;margin-top:10px;font-size:12px;">High Score: <span id="uiHi">0</span></div>
  </div>
</div>

<div id="paused" class="overlay" style="background:rgba(0,0,0,.35);">
  <div class="box">
    <div style="font-size:18px;font-weight:800;letter-spacing:.04em;">PAUSED</div>
    <div style="opacity:.85;margin-top:6px;font-size:13px;">Press P to resume</div>
  </div>
</div>

<div class="foot">Aero lift/drag · Ground-effect glide · Peakier mountains</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* ========= utils ========= */
function mulberry32(seed){ let t=seed>>>0; return ()=>{ t+=0x6D2B79F5; let r=Math.imul(t^(t>>>15),1|t); r^=r+Math.imul(r^(r>>>7),61|r); return ((r^(r>>>14))>>>0)/4294967296; }; }
const randRange=(rng,a,b)=>a+(b-a)*rng();
const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
const smooth=(t)=>t*t*(3-2*t); // smoothstep
const rad = THREE.MathUtils.degToRad;
// 32-bit value-noise (no BigInt)
function makeNoise2D(seed) {
  const s = seed | 0;
  function hash(i, j) {
    let h = ((i|0) * 374761393) ^ ((j|0) * 668265263) ^ (s * 362437);
    h = (h ^ (h >>> 13)) >>> 0;
    h = (h * 1274126177) >>> 0;
    return h / 4294967295;
  }
  return (x, z) => {
    const ix = Math.floor(x), iz = Math.floor(z);
    const fx = x - ix, fz = z - iz;
    const u = smooth(fx), v = smooth(fz);
    const n00 = hash(ix, iz),     n10 = hash(ix + 1, iz);
    const n01 = hash(ix, iz + 1), n11 = hash(ix + 1, iz + 1);
    const nx0 = n00 + (n10 - n00) * u;
    const nx1 = n01 + (n11 - n01) * u;
    return nx0 + (nx1 - nx0) * v; // 0..1
  };
}
function makeFBM(noise){ 
  return (x,z,oct=5,pers=0.5,lacun=2)=>{ 
    let f=1,a=1,acc=0,sum=0;
    for(let o=0;o<oct;o++){ acc+=a*noise(x*f,z*f); sum+=a; f*=lacun; a*=pers; }
    return acc/sum; // 0..1
  };
}
function ridged(n){ return 1 - Math.abs(2*n - 1); } // 0..1 → ridged 0..1

/* ========= DOM ========= */
const app = document.getElementById('app');
const uiScore = document.getElementById('uiScore');
const uiMult  = document.getElementById('uiMult');
const uiSpeed = document.getElementById('uiSpeed');
const uiAlt   = document.getElementById('uiAlt');
const uiSeed  = document.getElementById('uiSeed');
const uiDiff  = document.getElementById('uiDiff');
const crashEl = document.getElementById('crash');
const pausedEl= document.getElementById('paused');

/* ========= three setup ========= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(64, 1, 0.1, 30000);
camera.position.set(0, 1600, 4200);

const fogColor = new THREE.Color('#cfeaff');
scene.fog = new THREE.Fog(fogColor, 700, 22000);

const hemi = new THREE.HemisphereLight(0xcfeaff, 0xbfa17a, 0.95); hemi.position.set(0,1200,0); scene.add(hemi);
const dir  = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(-900,1600,1100); scene.add(dir);
const amb  = new THREE.AmbientLight(0xffffff, 0.22); scene.add(amb);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
app.appendChild(renderer.domElement);

/* ========= state ========= */
const inputs = { w:false,s:false,a:false,d:false,q:false,e:false };
let terrain = null;
let portalMesh = null;

const state = {
  playerPos: new THREE.Vector3(0,1600,4200),
  playerQuat: new THREE.Quaternion().multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), rad(8))),
  playerRadius: 1.0,
  vel: new THREE.Vector3(0,-16,-55),

  gravity: 9.0,       // real-ish gravity (game units)
  dragLinear: 0.02,   // small linear air damping to keep things stable

  // Aero model tuning (unitless gameplay constants)
  qScale: 0.015,      // dynamic pressure scale ~ v^2
  liftScale: 0.12,    // overall lift strength
  dragScale: 0.02,    // overall aero drag strength
  ClMax: 1.15,        // peak lift coefficient (game-scale)
  Cd0: 0.03,          // base drag
  CdK: 0.06,          // induced drag factor
  aoaLimit: rad(30),  // clamp AoA for stability
  groundEffectH: 140, // height where ground effect fades out
  groundEffectStrength: 0.9, // extra lift multiplier near ground when parallel

  maxSpeed: 170,

  yawRate:   rad(95),
  pitchRate: rad(75),
  rollRate:  rad(150),

  score: 0, multiplier: 1, maxMultiplier: 12, proxThreshold: 14.0,
  crashed:false, paused:false,
  worldSeed: Math.floor(Math.random()*1e9), difficulty:1,
  highScore:0,
};

/* ========= glider + shadow marker ========= */
function buildGlider(){
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.ConeGeometry(0.5,1.8,6), new THREE.MeshStandardMaterial({color:0xffffff, roughness:.4, metalness:.1}));
  body.rotation.x = Math.PI/2; g.add(body);
  const wing = new THREE.Mesh(new THREE.BoxGeometry(3.2, .08, .6), new THREE.MeshStandardMaterial({color:0x87ceeb, roughness:.6}));
  wing.position.set(0,0,-.1); g.add(wing);
  const tail = new THREE.Mesh(new THREE.BoxGeometry(.9,.06,.5), new THREE.MeshStandardMaterial({color:0x87ceeb, roughness:.6}));
  tail.position.set(0,-.2,.4); tail.rotation.z = rad(15); g.add(tail);
  return g;
}
const glider = buildGlider(); scene.add(glider);

function makeShadowTexture(){
  const s=64, cnv=document.createElement('canvas'); cnv.width=cnv.height=s;
  const ctx=cnv.getContext('2d');
  const g=ctx.createRadialGradient(s/2,s/2,8, s/2,s/2,s/2);
  g.addColorStop(0,'rgba(0,0,0,0.35)');
  g.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(s/2,s/2,s/2,0,Math.PI*2); ctx.fill();
  const tex = new THREE.CanvasTexture(cnv); tex.anisotropy = 4; return tex;
}
const shadowSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeShadowTexture(), transparent:true, depthWrite:false, opacity:.8 }));
shadowSprite.renderOrder = -1;
scene.add(shadowSprite);

/* ========= terrain (taller + peakier) ========= */
function buildTerrain(seed){
  const theme = {
    rockLo: new THREE.Color('#cda077'),
    rockHi: new THREE.Color('#8d6442'),
    grass:  new THREE.Color('#9ecb7a'),
    snow:   new THREE.Color('#f5f7fb')
  };

  const params = {
    width:  4200,     // wider map
    length: 16000,    // longer run
    segX:   360,      // higher mesh resolution
    segZ:   1100,
    amp:    1500,     // TALL mountains
    base:   -120,
    slope:  0.02,     // gentle downhill toward -Z
    nx:     0.0013,   // base noise scale
    nz:     0.0013,
    ridgeMix: 0.78,   // more ridges
    microAmp: 0.16,   // fine detail
    peakSharp: 2.1,   // peaky curve
  };

  const noise = makeNoise2D(seed ^ 0x9e3779b9);
  const fbm   = makeFBM(noise);

  function heightAt(x,z){
    const n1 = fbm(x*params.nx, z*params.nz, 6, 0.55, 2.05);                 // broad hills
    const n2 = ridged(fbm(x*params.nx*0.55, z*params.nz*0.55, 5, 0.5, 2.0)); // ridges
    const n3 = fbm(x*params.nx*4.2, z*params.nz*4.2, 3, 0.5, 2.0);           // micro detail
    const base = (1-params.ridgeMix)*n1 + params.ridgeMix*n2;                 // 0..1
    const peaky = 1 - Math.pow(1 - base, params.peakSharp);                   // peakify
    const shaped = clamp(peaky + (n3-0.5)*params.microAmp, 0, 1);
    const slopeTerm = (-(z + params.length*0.30) / params.length) * params.slope * params.amp;
    return params.base + shaped*params.amp + slopeTerm;
  }

  // plane geometry deformed by heightAt
  const geo = new THREE.PlaneGeometry(params.width, params.length, params.segX, params.segZ);
  geo.rotateX(-Math.PI/2);
  const pos = geo.attributes.position;
  const colors = new Float32Array((params.segX+1)*(params.segZ+1)*3);

  let i=0;
  for(let v=0; v<pos.count; v++){
    const x = pos.getX(v), z = pos.getZ(v);
    const y = heightAt(x,z);
    pos.setY(v, y);

    // vertex color by altitude with subtle contour bands
    const t = clamp((y - (params.base-100)) / (params.amp+300), 0, 1);
    let c = new THREE.Color();
    if (t < 0.45) c.lerpColors(theme.rockLo, theme.rockHi, t/0.45);
    else if (t < 0.80) c.lerpColors(theme.rockHi, theme.grass, (t-0.45)/0.35);
    else c.lerpColors(theme.grass, theme.snow, (t-0.80)/0.20);
    const band = ((Math.floor((y+120)/60)%2) ? 0.95 : 1.05);
    c.multiplyScalar(band);
    colors[i++]=c.r; colors[i++]=c.g; colors[i++]=c.b;
  }
  geo.setAttribute('color', new THREE.BufferAttribute(colors,3));
  geo.computeVertexNormals();

  const mat = new THREE.MeshStandardMaterial({ vertexColors:true, flatShading:false, roughness:0.95, metalness:0.02 });
  const mesh = new THREE.Mesh(geo, mat);

  // clouds
  const cloudGroup = buildCloudLayer(seed, params);

  // portal near far end above a valley
  const portalZ = -params.length/2 + 240;
  const portalY = heightAt(0, portalZ) + 80;
  const ringR=22, ringT=2.6;
  const portalMat = new THREE.MeshStandardMaterial({ color: 0x7aa2ff, emissive: new THREE.Color(0x7aa2ff).multiplyScalar(.6), roughness:.2, metalness:0.0 });
  const portalMeshLocal = new THREE.Mesh(new THREE.TorusGeometry(ringR, ringT, 18, 72), portalMat);
  portalMeshLocal.position.set(0, portalY, portalZ);
  portalMeshLocal.userData.center = portalMeshLocal.position.clone();
  portalMeshLocal.userData.ringR = ringR;
  portalMeshLocal.userData.thickness = ringT;

  const group = new THREE.Group();
  group.add(mesh);
  group.add(cloudGroup);
  group.add(portalMeshLocal);
  scene.add(group);

  return { group, params, heightAt, portal: portalMeshLocal };
}

// cloud sprites
function makeCloudTexture(){
  const s=128, cnv=document.createElement('canvas'); cnv.width=cnv.height=s;
  const ctx=cnv.getContext('2d');
  const g=ctx.createRadialGradient(s/2,s/2,12, s/2,s/2,s/2);
  g.addColorStop(0,'rgba(255,255,255,0.9)');
  g.addColorStop(1,'rgba(255,255,255,0.0)');
  ctx.fillStyle=g; ctx.fillRect(0,0,s, s);
  const tex = new THREE.CanvasTexture(cnv); tex.anisotropy = 4; return tex;
}
function buildCloudLayer(seed, params){
  const rng = mulberry32(seed ^ 0xabcdef);
  const tex = makeCloudTexture();
  const grp = new THREE.Group();
  const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false });
  const count = 200;
  for(let i=0;i<count;i++){
    const sp = new THREE.Sprite(spriteMat.clone());
    sp.position.set(randRange(rng,-params.width*0.7, params.width*0.7), 1700 + randRange(rng,-60,60), randRange(rng, -params.length*0.60, params.length*0.20));
    const s = randRange(rng, 140, 300);
    sp.scale.set(s, s, 1);
    sp.material.opacity = randRange(rng, 0.26, 0.6);
    grp.add(sp);
  }
  return grp;
}

/* ========= world management ========= */
function disposeWorld(){
  if (!terrain) return;
  scene.remove(terrain.group);
  terrain.group.traverse(o=>{ 
    if (o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); }
    if (o.isSprite){ o.material?.map?.dispose?.(); o.material?.dispose?.(); }
  });
  portalMesh = null;
  terrain = null;
}
function generateWorld(seed){
  disposeWorld();
  terrain = buildTerrain(seed);
  portalMesh = terrain.portal;
  uiSeed.textContent = seed;

  // start high & upstream relative to map size
  const startZ = terrain.params.length * 0.42;
  state.playerPos.set(0, 1600, startZ);
  state.playerQuat.identity().multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), rad(8)));
  state.vel.set(0, -16, -55);
}

/* ========= terrain helpers ========= */
function terrainHeightAt(x,z){ return terrain.heightAt(x,z); }
function terrainNormalAt(x,z){
  const e=6;
  const hL = terrainHeightAt(x-e,z), hR = terrainHeightAt(x+e,z);
  const hD = terrainHeightAt(x,z-e), hU = terrainHeightAt(x,z+e);
  // gradient: [-dh/dx, 1, -dh/dz]
  const nx = -(hR - hL) / (2*e);
  const ny = 1.0;
  const nz = -(hU - hD) / (2*e);
  const n = new THREE.Vector3(nx,ny,nz).normalize();
  return n;
}

/* ========= input ========= */
function setKey(e, down){
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  switch(e.code){
    case 'KeyW': case 'ArrowUp':    inputs.w = down; break; // W = nose down (plane feel)
    case 'KeyS': case 'ArrowDown':  inputs.s = down; break; // S = nose up
    case 'KeyA': case 'ArrowLeft':  inputs.a = down; break; // yaw left
    case 'KeyD': case 'ArrowRight': inputs.d = down; break; // yaw right
    case 'KeyQ': inputs.q = down; break;
    case 'KeyE': inputs.e = down; break;
    case 'KeyP': if(down) togglePause(); break;
    case 'KeyR': if(down) restart(); break;
  }
}
window.addEventListener('keydown', e=>setKey(e,true), {passive:false});
window.addEventListener('keyup',   e=>setKey(e,false), {passive:false});

/* ========= game flow ========= */
function doCrash(){ state.crashed=true; crashEl.style.display='grid'; state.highScore = Math.max(state.highScore, state.score|0); document.getElementById('uiHi').textContent = state.highScore.toFixed(0); }
function togglePause(){ state.paused=!state.paused; pausedEl.style.display = state.paused ? 'grid' : 'none'; }
function restart(){
  const startZ = terrain ? terrain.params.length * 0.42 : 4200;
  state.playerPos.set(0, 1600, startZ);
  state.playerQuat.identity().multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), rad(8)));
  state.vel.set(0, -16, -55);
  state.score=0; state.multiplier=1; state.crashed=false;
  crashEl.style.display='none';
}
function nextWorld(){
  state.worldSeed = (state.worldSeed * 1664525 + 1013904223) >>> 0;
  state.difficulty += 1;
  generateWorld(state.worldSeed);
}

/* ========= layout ========= */
function resize(){
  const w=window.innerWidth, h=window.innerHeight;
  renderer.setSize(w,h);
  camera.aspect = w/h; camera.updateProjectionMatrix();
}
window.addEventListener('resize', resize);
resize();

generateWorld(state.worldSeed);

/* ========= loop (aero physics) ========= */
function terrainDistanceBelow(pos){
  const yGround = terrainHeightAt(pos.x, pos.z);
  return pos.y - yGround;
}

const clock = new THREE.Clock();
renderer.setAnimationLoop(()=>{
  const dt = Math.min(0.05, clock.getDelta());
  if (state.paused || state.crashed) { renderer.render(scene,camera); return; }

  // controls → orientation (plane-like)
  const yaw   = ((inputs.a?1:0) - (inputs.d?1:0)) * state.yawRate   * dt; // A left, D right
  const pitch = ((inputs.s?1:0) - (inputs.w?1:0)) * state.pitchRate * dt; // W nose down, S up
  const roll  = ((inputs.q?1:0) - (inputs.e?1:0)) * state.rollRate  * dt; // Q left, E right

  const qYaw   = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),  yaw);
  const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),  pitch);
  const qRoll  = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -roll);
  state.playerQuat.multiply(qYaw).multiply(qPitch).multiply(qRoll).normalize();

  // current basis vectors
  const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(state.playerQuat).normalize();
  const up  = new THREE.Vector3(0,1,0).applyQuaternion(state.playerQuat).normalize();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(state.playerQuat).normalize();

  // velocity + aero
  const v = state.vel.clone();
  const spd = v.length();
  const air = spd > 0.0001 ? v.clone().multiplyScalar(-1/spd) : fwd.clone().negate(); // relative wind
  // angle of attack = angle between forward and relative wind inside (forward, up) plane
  const aoa = clamp(Math.atan2( up.dot(air), fwd.dot(air) ), -state.aoaLimit, state.aoaLimit);

  // coefficients
  const Cl = state.ClMax * Math.sin(2*aoa);           // lift curve (approx)
  const Cd = state.Cd0  + state.CdK * (Cl*Cl);        // drag increases with lift

  // dynamic pressure (scaled)
  const q = (spd*spd) * state.qScale;

  // lift direction: up projected onto plane perpendicular to airflow (banking rolls lift)
  let liftDir = up.clone().projectOnPlane(air);
  const liftDirLen = liftDir.length();
  if (liftDirLen < 1e-5) liftDir.copy(up); else liftDir.multiplyScalar(1/liftDirLen);

  // ground effect & "parallel to ground" boost
  const alt = terrainDistanceBelow(state.playerPos);
  const gNorm = terrainNormalAt(state.playerPos.x, state.playerPos.z);
  const parallelFactor = 1 - Math.abs(fwd.dot(gNorm)); // 0 ⟂ (perpendicular), 1 ∥ (parallel)
  const geAlt = clamp(1 - alt / state.groundEffectH, 0, 1); // only near ground
  const groundEffectBoost = 1 + state.groundEffectStrength * geAlt * Math.pow(parallelFactor, 1.2);

  // forces
  const liftMag = q * Cl * state.liftScale * groundEffectBoost;
  const dragMag = q * Cd * state.dragScale;

  const gravity = new THREE.Vector3(0, -state.gravity, 0);
  const lift    = liftDir.multiplyScalar(liftMag);
  const drag    = spd>0.0001 ? v.clone().multiplyScalar(-1/spd * dragMag) : new THREE.Vector3();

  // mild linear air damping to prevent runaway
  const linearDamp = v.clone().multiplyScalar(-state.dragLinear);

  // Update velocity
  state.vel.addScaledVector(gravity, dt);
  state.vel.addScaledVector(lift, dt);
  state.vel.addScaledVector(drag, dt);
  state.vel.addScaledVector(linearDamp, dt);

  // Gentle forward nudge if nearly stopped (keeps the run flowing)
  const horiz = new THREE.Vector3(state.vel.x,0,state.vel.z);
  if (horiz.length() < 6){
    const fH = new THREE.Vector3(fwd.x,0,fwd.z).normalize();
    state.vel.addScaledVector(fH, (6 - horiz.length()) * 0.25 * dt * 60);
  }

  // clamp speed
  const spdNew = state.vel.length();
  if (spdNew > state.maxSpeed) state.vel.multiplyScalar(state.maxSpeed / spdNew);

  // integrate position
  state.playerPos.addScaledVector(state.vel, dt);

  // camera (a bit back/above)
  const camOffLocal = new THREE.Vector3(0, 4.0, 16.0);
  const camPos = camOffLocal.clone().applyQuaternion(state.playerQuat).add(state.playerPos);
  camera.position.lerp(camPos, 0.16);
  camera.lookAt(state.playerPos.clone().add(fwd.clone().multiplyScalar(32)));

  // glider mesh
  glider.position.copy(state.playerPos);
  glider.quaternion.copy(state.playerQuat);

  // ground collision/proximity
  const distBelow = alt; // already computed
  const nearestDist = distBelow - state.playerRadius;
  if (nearestDist < 0) { doCrash(); renderer.render(scene,camera); return; }

  // shadow marker for depth cues
  const yGround = state.playerPos.y - distBelow;
  const shadowSize = clamp(30 + distBelow*0.12, 30, 520);
  const shadowAlpha = clamp(0.85 - distBelow/1400, 0.12, 0.85);
  shadowSprite.position.set(state.playerPos.x, yGround + 0.2, state.playerPos.z);
  shadowSprite.scale.set(shadowSize, shadowSize, 1);
  shadowSprite.material.opacity = shadowAlpha;

  // scoring (closer to ground ⇒ more score)
  const closeness = clamp(1 - (nearestDist / state.proxThreshold), 0, 1);
  const gain = (4 + spdNew * 0.16) * state.multiplier * (0.25 + closeness * 1.4);
  state.score += gain * dt;
  if (closeness > 0.15) state.multiplier = Math.min(state.maxMultiplier, state.multiplier + dt * (0.15 + closeness * 0.45));
  else state.multiplier = Math.max(1, state.multiplier - dt * 1.0);

  // portal at far end
  if (portalMesh){
    const c = portalMesh.userData.center, ringR=portalMesh.userData.ringR, thick=portalMesh.userData.thickness;
    const dx=state.playerPos.x-c.x, dz=state.playerPos.z-c.z, dy=Math.abs(state.playerPos.y-c.y);
    const radial=Math.hypot(dx,dz);
    if (Math.abs(radial - ringR) < thick*0.7 && dy < thick*0.9) nextWorld();
  }

  // HUD
  uiScore.textContent = state.score.toFixed(0);
  uiMult.textContent  = state.multiplier.toFixed(1);
  uiSpeed.textContent = spdNew.toFixed(1);
  uiAlt.textContent   = distBelow.toFixed(0);
  uiSeed.textContent  = state.worldSeed;
  uiDiff.textContent  = state.difficulty;

  renderer.render(scene, camera);
});
</script>
</body>
</html>

