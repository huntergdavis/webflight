import React, { useEffect, useMemo, useRef, useState } from "react";
import * as THREE from "three";

/**
 * Superflight (clean-room), client-side WebGL prototype
 * ----------------------------------------------------
 * - React + Three.js single-file implementation
 * - Procedural "worlds" with rocky spires, arches, and a tube-like cave
 * - Third-person wingsuit flight with pitch/yaw/roll, proximity scoring, portals to new worlds
 * - Minimal HUD (score, multiplier, speed, seed, help)
 *
 * Notes
 * -----
 * This is a compact MVP aimed at demonstrating the full loop:
 *   input → flight model → collision/proximity → scoring → portal → next world
 * For clarity and portability, the code avoids external helper libs. Three.js is the only dependency.
 * The collider system uses coarse spheres on obstacles for performance & simplicity.
 *
 * Controls
 * --------
 *   Mouse move  : pitch (vertical) + yaw (horizontal)
 *   W / S       : pitch up / down (adds to mouse)
 *   A / D       : roll left / right
 *   Q / E       : yaw left / right
 *   R           : restart after crash
 *   P           : pause/resume
 *
 * Tuning points are marked with //! TUNE.
 */

// -------------------- Utility: seeded RNG --------------------
function mulberry32(seed) {
  let t = seed >>> 0;
  return function () {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}

function randRange(rng, min, max) {
  return min + (max - min) * rng();
}

function choose(rng, arr) {
  return arr[Math.floor(rng() * arr.length)];
}

// -------------------- Color Palettes --------------------
const THEMES = [
  // terrain, portal, skyTop, skyBottom
  [0x5c715e, 0xffcc66, 0x3a4d73, 0x87b7e6], // pine + amber, dusk sky
  [0x6c5b7b, 0xf67280, 0x2a2b4a, 0x7a85a3], // mauve + coral, twilight
  [0x3a7d44, 0xfaf3dd, 0x274060, 0x97c1e7], // forest + cream, cool
  [0x8e5a33, 0xf2d492, 0x3c3e44, 0x99b2c6], // canyon + sand, overcast
  [0x3d405b, 0xe07a5f, 0x16222a, 0x3a6073], // slate + orange, moody
];

// -------------------- Types --------------------
/** Collider shape (all spheres for simplicity) */
class SphereCollider {
  constructor(center, radius, tag = "rock") {
    this.center = center; // THREE.Vector3
    this.radius = radius; // number
    this.tag = tag; // "rock" | "portal"
  }
}

// -------------------- Main Component --------------------
export default function SuperflightCleanRoom() {
  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const rafRef = useRef(0);
  const gliderRef = useRef(null);
  const worldGroupRef = useRef(null);
  const portalMeshRef = useRef(null);
  const collidersRef = useRef([]);

  const [ui, setUI] = useState({
    score: 0,
    multiplier: 1,
    speed: 0,
    crashed: false,
    paused: false,
    worldSeed: 1,
    highScore: 0,
    difficulty: 1,
  });

  // Input state
  const inputsRef = useRef({
    keyW: false,
    keyS: false,
    keyA: false,
    keyD: false,
    keyQ: false,
    keyE: false,
    mouseX: 0,
    mouseY: 0,
    lastMouseX: 0,
    lastMouseY: 0,
    mouseDX: 0,
    mouseDY: 0,
    hasMouse: false,
  });

  // Game/physics state
  const stateRef = useRef({
    playerPos: new THREE.Vector3(0, 5, 10),
    playerQuat: new THREE.Quaternion(),
    playerRadius: 0.8, // //! TUNE

    baseSpeed: 40, // //! TUNE: forward speed baseline
    maxSpeed: 95,
    speed: 40,
    speedGain: 45, // how much pitching down increases speed

    yawRate: THREE.MathUtils.degToRad(80), // //! TUNE
    pitchRate: THREE.MathUtils.degToRad(65),
    rollRate: THREE.MathUtils.degToRad(120),

    score: 0,
    multiplier: 1,
    maxMultiplier: 12,
    proxThreshold: 6.0, // distance to surface where proximity starts counting
    proxActive: false,
    proxTimer: 0,
    proxDropTimer: 0,

    crashed: false,
    paused: false,
    worldSeed: Math.floor(Math.random() * 1e9),
    difficulty: 1,

    // book-keeping
    lastTime: 0,
  });

  // ------------- Scene Setup -------------
  useEffect(() => {
    const container = mountRef.current;
    const scene = new THREE.Scene();
    sceneRef.current = scene;

    // Sky (vertical gradient via fog + big ambient light)
    const themeIndex = 0;
    const theme = THEMES[themeIndex];
    const skyTop = new THREE.Color(theme[2]);
    const skyBottom = new THREE.Color(theme[3]);

    // Fake gradient by fog color interpolation; also add a big sky dome.
    scene.fog = new THREE.Fog(skyBottom.getHex(), 60, 500);

    // Camera
    const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 2000);
    camera.position.set(0, 6, 18);
    cameraRef.current = camera;

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    hemi.position.set(0, 200, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(-30, 50, 10);
    scene.add(dir);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    rendererRef.current = renderer;
    container.appendChild(renderer.domElement);

    // Glider visual
    const glider = buildGliderMesh();
    gliderRef.current = glider;
    scene.add(glider);

    // World group placeholder
    const world = new THREE.Group();
    worldGroupRef.current = world;
    scene.add(world);

    // Generate first world
    generateWorld(stateRef.current.worldSeed, scene, world, collidersRef, portalMeshRef);

    // Events
    const onResize = () => {
      if (!container || !rendererRef.current || !cameraRef.current) return;
      const w = container.clientWidth;
      const h = container.clientHeight;
      rendererRef.current.setSize(w, h);
      cameraRef.current.aspect = w / h;
      cameraRef.current.updateProjectionMatrix();
    };
    window.addEventListener("resize", onResize);

    const onKey = (e, down) => {
      const i = inputsRef.current;
      switch (e.code) {
        case "KeyW": i.keyW = down; break;
        case "KeyS": i.keyS = down; break;
        case "KeyA": i.keyA = down; break;
        case "KeyD": i.keyD = down; break;
        case "KeyQ": i.keyQ = down; break;
        case "KeyE": i.keyE = down; break;
        case "KeyR": if (down) restart(); break;
        case "KeyP": if (down) togglePause(); break;
        default: break;
      }
    };
    const onKeyDown = (e) => onKey(e, true);
    const onKeyUp = (e) => onKey(e, false);
    window.addEventListener("keydown", onKeyDown);
    window.addEventListener("keyup", onKeyUp);

    const onMouseMove = (e) => {
      const i = inputsRef.current;
      i.hasMouse = true;
      const rect = renderer.domElement.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      i.mouseDX = x - i.lastMouseX;
      i.mouseDY = y - i.lastMouseY;
      i.lastMouseX = x;
      i.lastMouseY = y;
    };
    renderer.domElement.addEventListener("mousemove", onMouseMove);

    const prevent = (e) => e.preventDefault();
    renderer.domElement.addEventListener("wheel", prevent, { passive: false });

    // Start loop
    const clock = new THREE.Clock();
    stateRef.current.lastTime = 0;
    const loop = () => {
      rafRef.current = requestAnimationFrame(loop);
      const dt = clock.getDelta();
      tick(dt);
      renderer.render(scene, camera);
    };
    loop();

    // Cleanup
    return () => {
      cancelAnimationFrame(rafRef.current);
      window.removeEventListener("resize", onResize);
      window.removeEventListener("keydown", onKeyDown);
      window.removeEventListener("keyup", onKeyUp);
      renderer.domElement.removeEventListener("mousemove", onMouseMove);
      renderer.domElement.removeEventListener("wheel", prevent);

      disposeWorld(worldGroupRef.current);
      if (gliderRef.current) gliderRef.current.geometry.dispose();
      if (gliderRef.current && gliderRef.current.material) gliderRef.current.material.dispose();

      renderer.dispose();
      container.removeChild(renderer.domElement);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // ------------- Core Tick -------------
  const tick = (dt) => {
    const st = stateRef.current;
    const cam = cameraRef.current;
    const glider = gliderRef.current;
    if (!cam || !glider) return;

    if (st.paused) return;

    // Skip updates after crash (wait for R)
    if (st.crashed) return;

    // INPUT → ORIENTATION
    const inp = inputsRef.current;

    // Mouse deltas → small rates (frame-local), smoothed a bit
    const mouseYaw = THREE.MathUtils.clamp(inp.mouseDX * 0.0025, -0.8, 0.8); // //! TUNE
    const mousePitch = THREE.MathUtils.clamp(-inp.mouseDY * 0.0025, -0.8, 0.8);
    // Reset deltas so we measure per-frame movement
    inp.mouseDX *= 0.2; // slight decay to smooth
    inp.mouseDY *= 0.2;

    const yawInput = (inp.keyQ ? 1 : 0) * st.yawRate * dt * 0.9 + mouseYaw * st.yawRate * dt;
    const pitchInput = ((inp.keyS ? 1 : 0) - (inp.keyW ? 1 : 0)) * st.pitchRate * dt * 0.8 + mousePitch * st.pitchRate * dt;
    const rollInput = ((inp.keyD ? 1 : 0) - (inp.keyA ? 1 : 0)) * st.rollRate * dt;

    const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yawInput);
    const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitchInput);
    const qRoll = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), -rollInput);

    st.playerQuat.multiply(qYaw).multiply(qPitch).multiply(qRoll);
    st.playerQuat.normalize();

    // SPEED from pitch (nose down → faster)
    const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(st.playerQuat);
    const pitchDown = Math.max(0, -fwd.y); // -y means pointing down
    const targetSpeed = THREE.MathUtils.clamp(
      st.baseSpeed + pitchDown * st.speedGain + st.difficulty * 2,
      st.baseSpeed * 0.6,
      st.maxSpeed
    );
    st.speed = THREE.MathUtils.damp(st.speed, targetSpeed, 3.0, dt);

    // MOVE
    const delta = fwd.clone().multiplyScalar(st.speed * dt);
    st.playerPos.add(delta);

    // CAMERA (third-person chase)
    const camOffset = new THREE.Vector3(0, 1.8, 7.5); // behind and above
    const camPos = camOffset.clone().applyQuaternion(st.playerQuat).add(st.playerPos);
    cam.position.lerp(camPos, 0.25);
    const lookAt = st.playerPos.clone().add(fwd.clone().multiplyScalar(12));
    cam.lookAt(lookAt);

    // Update glider transform
    glider.position.copy(st.playerPos);
    glider.quaternion.copy(st.playerQuat);

    // COLLISIONS + PROXIMITY
    const { nearestDist, nearestTag } = nearestCollider(st.playerPos, st.playerRadius, collidersRef.current);

    // Crash if we overlap any collider
    if (nearestDist < 0) {
      doCrash();
      return;
    }

    // Proximity scoring
    const proxActive = nearestDist < stateRef.current.proxThreshold;
    if (proxActive) {
      st.proxTimer += dt;
      st.proxDropTimer = 0;
      // scale by closeness + speed
      const closeness = 1 - THREE.MathUtils.clamp(nearestDist / st.proxThreshold, 0, 1);
      const gain = (5 + st.speed * 0.2) * st.multiplier * (0.25 + closeness * 1.25); // //! TUNE
      st.score += gain * dt;
      // build multiplier over sustained proximity
      if (st.proxTimer > 1.5 && st.multiplier < st.maxMultiplier) {
        st.multiplier = Math.min(st.maxMultiplier, st.multiplier + 0.2 * dt * (1 + closeness * 2));
      }
    } else {
      st.proxDropTimer += dt;
      st.proxTimer = Math.max(0, st.proxTimer - dt * 0.5);
      if (st.proxDropTimer > 0.8) {
        st.multiplier = Math.max(1, st.multiplier - dt * 2.5);
      }
    }

    // PORTAL: If close to portal center and roughly aligned, transition
    if (portalMeshRef.current) {
      const portal = portalMeshRef.current;
      const center = portal.userData.center; // Vector3
      const ringR = portal.userData.ringR;
      const thickness = portal.userData.thickness;
      const d = st.playerPos.distanceTo(center);

      // Require player to be near the ring and within a thin shell
      if (Math.abs(d - ringR) < thickness * 0.6) {
        // also require facing approximately toward -Z (continue forward)
        nextWorld();
      }
    }

    // UI sync (throttle updates a bit if desired)
    setUI((u) => ({
      ...u,
      score: st.score,
      multiplier: st.multiplier,
      speed: st.speed,
      crashed: st.crashed,
      paused: st.paused,
      worldSeed: st.worldSeed,
      difficulty: st.difficulty,
      highScore: Math.max(u.highScore, st.score | 0),
    }));
  };

  // ------------- Collision helpers -------------
  function nearestCollider(playerPos, playerRadius, colliders) {
    let min = Infinity;
    let tag = null;
    // simple broad-phase: only check within 120 units
    for (let i = 0; i < colliders.length; i++) {
      const c = colliders[i];
      const d = playerPos.distanceTo(c.center) - (c.radius + playerRadius);
      if (d < min) { min = d; tag = c.tag; }
    }
    if (!isFinite(min)) min = 9999;
    return { nearestDist: min, nearestTag: tag };
  }

  // ------------- Crash / Restart / Pause -------------
  function doCrash() {
    const st = stateRef.current;
    st.crashed = true;
    setUI((u) => ({ ...u, crashed: true, highScore: Math.max(u.highScore, st.score | 0) }));
  }

  function restart() {
    const st = stateRef.current;
    st.playerPos.set(0, 5, 10);
    st.playerQuat.identity();
    st.speed = st.baseSpeed;
    st.score = 0;
    st.multiplier = 1;
    st.proxTimer = 0;
    st.proxDropTimer = 0;
    st.crashed = false;
    // keep current world/seed
  }

  function togglePause() {
    const st = stateRef.current;
    st.paused = !st.paused;
    setUI((u) => ({ ...u, paused: st.paused }));
  }

  function nextWorld() {
    const st = stateRef.current;
    st.worldSeed = (st.worldSeed * 1664525 + 1013904223) >>> 0; // LCG advance
    st.difficulty += 1;
    // carry momentum/speed/score; do not reset score or multiplier
    const scene = sceneRef.current;
    disposeWorld(worldGroupRef.current);
    generateWorld(st.worldSeed, scene, worldGroupRef.current, collidersRef, portalMeshRef, st);
  }

  // ------------- World Generation -------------
  function generateWorld(seed, scene, worldGroup, collidersRef, portalMeshRef, stOpt) {
    const rng = mulberry32(seed >>> 0);
    const theme = choose(rng, THEMES);

    // Clear previous
    worldGroup.clear();
    collidersRef.current = [];

    // Sky fog color tweak per world
    if (scene && scene.fog) {
      scene.fog.color.setHex(theme[3]);
    }

    // Terrain materials
    const rockMat = new THREE.MeshStandardMaterial({ color: theme[0], roughness: 0.9, metalness: 0.0 });
    const decoMat = new THREE.MeshStandardMaterial({ color: theme[1], roughness: 0.5, metalness: 0.0, emissive: new THREE.Color(theme[1]).multiplyScalar(0.05) });

    // --- Spire fields ---
    const spireCount = 60 + Math.floor((stOpt?.difficulty || 1) * 10); // //! TUNE density
    for (let i = 0; i < spireCount; i++) {
      const x = randRange(rng, -40, 40);
      const z = randRange(rng, -1500, -100);
      const baseY = randRange(rng, -5, 12);
      const height = randRange(rng, 8, 28);
      const radius = randRange(rng, 1.8, 4.5);

      const g = new THREE.CylinderGeometry(radius * 0.8, radius, height, 6, 1);
      const m = new THREE.Mesh(g, rockMat);
      m.position.set(x, baseY + height * 0.5, z);
      m.rotation.y = randRange(rng, 0, Math.PI * 2);
      worldGroup.add(m);

      // Build stacked sphere colliders up the spire for coarse collision
      const layers = Math.max(3, Math.floor(height / 4));
      for (let j = 0; j < layers; j++) {
        const cy = m.position.y - height * 0.5 + (j + 0.5) * (height / layers);
        const r = radius * 0.75;
        collidersRef.current.push(new SphereCollider(new THREE.Vector3(x, cy, z), r, "rock"));
      }
    }

    // --- Arches (decor + mild collision via spheres) ---
    const archCount = 10 + Math.floor((stOpt?.difficulty || 1) * 2);
    for (let a = 0; a < archCount; a++) {
      const center = new THREE.Vector3(randRange(rng, -30, 30), randRange(rng, 2, 18), randRange(rng, -1300, -200));
      const radius = randRange(rng, 6, 12);
      const tube = 1.2;
      const torus = new THREE.TorusGeometry(radius, tube, 8, 24);
      const mesh = new THREE.Mesh(torus, rockMat);
      mesh.position.copy(center);
      mesh.rotation.x = randRange(rng, 0, Math.PI);
      mesh.rotation.y = randRange(rng, 0, Math.PI);
      worldGroup.add(mesh);

      // collider ring as spaced spheres around the circle (coarse!)
      const ringCount = 16;
      for (let k = 0; k < ringCount; k++) {
        const ang = (k / ringCount) * Math.PI * 2;
        const px = center.x + Math.cos(ang) * radius;
        const py = center.y + Math.sin(ang) * radius;
        const pz = center.z;
        collidersRef.current.push(new SphereCollider(new THREE.Vector3(px, py, pz), tube * 0.9, "rock"));
      }
    }

    // --- Cave tunnel (visual)
    const pathPts = [];
    const segs = 18;
    let zCursor = -50;
    let cx = 0, cy = 6;
    for (let i = 0; i < segs; i++) {
      cx += randRange(rng, -10, 10);
      cy += randRange(rng, -2.5, 2.5);
      zCursor -= randRange(rng, 50, 110);
      pathPts.push(new THREE.Vector3(cx, cy, zCursor));
    }
    const curve = new THREE.CatmullRomCurve3(pathPts);
    const caveRadius = 6 + randRange(rng, -1.0, 2.0);
    const caveGeom = new THREE.TubeGeometry(curve, 180, caveRadius, 14, false);
    // Render inside of tube for a cave feel
    const caveMat = new THREE.MeshStandardMaterial({ color: theme[0], roughness: 0.95, metalness: 0.0, side: THREE.BackSide });
    const caveMesh = new THREE.Mesh(caveGeom, caveMat);
    worldGroup.add(caveMesh);

    // (Optional) sparse boulders near cave exit for proximity fun
    for (let i = 0; i < 24; i++) {
      const t = rng();
      const p = curve.getPoint(t);
      const off = new THREE.Vector3(randRange(rng, -caveRadius * 0.8, caveRadius * 0.8), randRange(rng, -caveRadius * 0.8, caveRadius * 0.8), randRange(rng, -caveRadius * 0.8, caveRadius * 0.8));
      const pos = p.clone().add(off);
      const r = randRange(rng, 0.8, 2.2);
      const g = new THREE.IcosahedronGeometry(r, 0);
      const m = new THREE.Mesh(g, rockMat);
      m.position.copy(pos);
      worldGroup.add(m);
      collidersRef.current.push(new SphereCollider(pos.clone(), r * 0.9, "rock"));
    }

    // --- Portal ---
    const portalZ = -1500 - randRange(rng, 0, 400);
    const portalCenter = new THREE.Vector3(randRange(rng, -8, 8), randRange(rng, 3, 12), portalZ);
    const ringR = 7.5;
    const ringThickness = 1.2;
    const portalGeo = new THREE.TorusGeometry(ringR, ringThickness, 16, 36);
    const portalMat = new THREE.MeshStandardMaterial({ color: theme[1], emissive: new THREE.Color(theme[1]).multiplyScalar(0.35), roughness: 0.2, metalness: 0.0 });
    const portalMesh = new THREE.Mesh(portalGeo, portalMat);
    portalMesh.position.copy(portalCenter);
    portalMesh.rotation.x = Math.PI / 2; // face toward +Z/-Z
    portalMesh.userData.center = portalCenter;
    portalMesh.userData.ringR = ringR;
    portalMesh.userData.thickness = ringThickness;
    worldGroup.add(portalMesh);
    portalMeshRef.current = portalMesh;

    // Also add a mild collider "shell" so you cannot clip through the ring geometry itself
    collidersRef.current.push(new SphereCollider(portalCenter.clone().add(new THREE.Vector3(ringR, 0, 0)), ringThickness * 0.9, "portal"));
    collidersRef.current.push(new SphereCollider(portalCenter.clone().add(new THREE.Vector3(-ringR, 0, 0)), ringThickness * 0.9, "portal"));
    collidersRef.current.push(new SphereCollider(portalCenter.clone().add(new THREE.Vector3(0, ringR, 0)), ringThickness * 0.9, "portal"));
    collidersRef.current.push(new SphereCollider(portalCenter.clone().add(new THREE.Vector3(0, -ringR, 0)), ringThickness * 0.9, "portal"));

    // Subtle dust/particles near portal for vibe
    const dust = buildDustField(theme[1]);
    dust.position.copy(portalCenter);
    worldGroup.add(dust);

    // Decorative horizon dots (stars-ish)
    const stars = buildStars(theme[2], theme[3]);
    worldGroup.add(stars);
  }

  function disposeWorld(group) {
    if (!group) return;
    group.traverse((obj) => {
      if (obj.isMesh) {
        obj.geometry?.dispose?.();
        if (obj.material?.isMaterial) {
          obj.material.dispose?.();
        }
      }
    });
    group.clear();
  }

  // ------------- Mesh Builders -------------
  function buildGliderMesh() {
    const g = new THREE.Group();
    const bodyGeo = new THREE.ConeGeometry(0.5, 1.8, 6);
    const wingGeo = new THREE.BoxGeometry(3.2, 0.08, 0.6);
    const tailGeo = new THREE.BoxGeometry(0.9, 0.06, 0.5);
    const matBody = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4, metalness: 0.1 });
    const matWing = new THREE.MeshStandardMaterial({ color: 0x87ceeb, roughness: 0.6, metalness: 0.0 });

    const body = new THREE.Mesh(bodyGeo, matBody);
    body.rotation.x = Math.PI / 2;
    g.add(body);

    const wing = new THREE.Mesh(wingGeo, matWing);
    wing.position.set(0, 0, -0.1);
    g.add(wing);

    const tail = new THREE.Mesh(tailGeo, matWing);
    tail.position.set(0, -0.2, 0.4);
    tail.rotation.z = THREE.MathUtils.degToRad(15);
    g.add(tail);

    return g;
  }

  function buildDustField(colorHex) {
    const count = 400;
    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
      positions[i * 3 + 0] = (Math.random() - 0.5) * 25;
      positions[i * 3 + 1] = (Math.random() - 0.5) * 25;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 25;
    }
    geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    const mat = new THREE.PointsMaterial({ color: colorHex, size: 0.06, transparent: true, opacity: 0.8 });
    return new THREE.Points(geo, mat);
  }

  function buildStars(colorTop, colorBottom) {
    const count = 800;
    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
      const r = 600 + Math.random() * 400;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      positions[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = r * Math.cos(phi);
      positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
    }
    geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    const mat = new THREE.PointsMaterial({ color: colorTop, size: 0.8, transparent: true, opacity: 0.35 });
    return new THREE.Points(geo, mat);
  }

  // ------------- Render -------------
  return (
    <div className="w-full h-[80vh] relative select-none">
      <div ref={mountRef} className="absolute inset-0 bg-gradient-to-b from-slate-800 to-slate-900 rounded-2xl overflow-hidden" />

      {/* HUD */}
      <div className="absolute top-2 left-2 p-2 rounded-xl bg-black/30 text-white text-sm leading-tight">
        <div className="font-semibold">Score: {ui.score.toFixed(0)}</div>
        <div>× Mult: {ui.multiplier.toFixed(1)}</div>
        <div>Speed: {ui.speed.toFixed(1)}</div>
        <div>Seed: {ui.worldSeed}</div>
        <div>Diff: {ui.difficulty}</div>
      </div>

      {/* Center reticle */}
      <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 text-white opacity-60" style={{ pointerEvents: "none" }}>
        <div className="w-1 h-6 bg-white/70 mx-auto rounded" />
        <div className="w-6 h-1 bg-white/70 mx-auto rounded" />
      </div>

      {/* Help / status */}
      <div className="absolute right-2 top-2 p-2 rounded-xl bg-black/30 text-white text-xs max-w-[260px]">
        <div className="font-semibold">Controls</div>
        <div>Mouse: pitch + yaw</div>
        <div>W/S: pitch · A/D: roll</div>
        <div>Q/E: yaw · P: pause</div>
        <div>R: restart after crash</div>
      </div>

      {/* Crash Overlay */}
      {ui.crashed && (
        <div className="absolute inset-0 grid place-items-center bg-red-900/30 text-white">
          <div className="bg-black/50 px-6 py-4 rounded-2xl text-center">
            <div className="text-2xl font-bold tracking-wide">CRASHED</div>
            <div className="mt-1 text-sm opacity-80">Press R to restart</div>
            <div className="mt-3 text-xs opacity-80">High Score: {ui.highScore.toFixed(0)}</div>
          </div>
        </div>
      )}

      {/* Pause Overlay */}
      {ui.paused && !ui.crashed && (
        <div className="absolute inset-0 grid place-items-center bg-black/40 text-white">
          <div className="bg-black/50 px-6 py-4 rounded-2xl text-center">
            <div className="text-xl font-bold tracking-wide">PAUSED</div>
            <div className="mt-1 text-sm opacity-80">Press P to resume</div>
          </div>
        </div>
      )}

      {/* Footer tip */}
      <div className="absolute bottom-2 left-1/2 -translate-x-1/2 text-white text-[11px] opacity-70 bg-black/30 px-2 py-1 rounded-full">
        Superflight (clean-room) · Procedural worlds · Fly dangerously for more points
      </div>
    </div>
  );
}

