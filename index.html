<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Superflight (clean-room) — Arcade Aero + Peak LOD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:linear-gradient(#a7d3ff,#eaf6ff); font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    #app { position:fixed; inset:0; overflow:hidden; }
    .hud { position:absolute; top:8px; left:8px; color:#003; background:rgba(255,255,255,.6); padding:8px 10px; border-radius:12px; font-size:13px; line-height:1.15; backdrop-filter:saturate(1.2) blur(2px); }
    .ret { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); color:#000; opacity:.25; pointer-events:none; }
    .ret div { background:rgba(0,0,0,.6); border-radius:2px; margin:auto; }
    .ret .v { width:4px; height:20px; }
    .ret .h { width:20px; height:4px; margin-top:4px; }
    .help { position:absolute; right:8px; top:8px; color:#003; background:rgba(255,255,255,.6); padding:8px 10px; border-radius:12px; font-size:12px; max-width:380px; backdrop-filter:saturate(1.2) blur(2px); }
    .overlay { position:absolute; inset:0; display:none; place-items:center; color:#fff; }
    .overlay .box { background:rgba(0,0,0,.6); padding:16px 20px; border-radius:18px; text-align:center; }
    .foot { position:absolute; left:50%; bottom:8px; transform:translateX(-50%); color:#003; font-size:11px; background:rgba(255,255,255,.6); padding:4px 8px; border-radius:999px; opacity:.9; }
    #err { position:fixed; right:8px; bottom:8px; max-width:46ch; background:#220; color:#fee; font:12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding:8px 10px; border-radius:12px; display:none; white-space:pre-wrap; }
  </style>
</head>
<body>
<div id="app"></div>

<div class="hud">
  <div><b>Score:</b> <span id="uiScore">0</span></div>
  <div>× <b>Mult:</b> <span id="uiMult">1.0</span></div>
  <div><b>Speed:</b> <span id="uiSpeed">0</span></div>
  <div><b>Alt:</b> <span id="uiAlt">0</span> m</div>
  <div><b>Seed:</b> <span id="uiSeed">0</span></div>
  <div><b>Diff:</b> <span id="uiDiff">1</span></div>
  <div><b>Quality:</b> <span id="uiQual">High</span></div>
</div>

<div class="ret"><div class="v"></div><div class="h"></div></div>

<div class="help">
  <div style="font-weight:600;margin-bottom:4px">Controls</div>
  <div>W/S or ↑/↓: pitch (W = nose down, S = nose up)</div>
  <div>A/D or ←/→: yaw (A = left, D = right)</div>
  <div>Q/E: roll</div>
  <div>P: pause · R: restart · 1: High · 2: Ultra (10×) · N: new seed</div>
</div>

<div id="crash" class="overlay" style="background:rgba(177,0,0,.35);">
  <div class="box">
    <div style="font-size:24px;font-weight:800;letter-spacing:.04em;">CRASHED</div>
    <div style="opacity:.85;margin-top:6px;font-size:13px;">Press R to restart</div>
    <div style="opacity:.75;margin-top:10px;font-size:12px;">High Score: <span id="uiHi">0</span></div>
  </div>
</div>

<div id="paused" class="overlay" style="background:rgba(0,0,0,.35);">
  <div class="box">
    <div style="font-size:18px;font-weight:800;letter-spacing:.04em;">PAUSED</div>
    <div style="opacity:.85;margin-top:6px;font-size:13px;">Press P to resume</div>
  </div>
</div>

<div class="foot">Arcade aero (loops/banked turns) · Peak terrain LOD · Clouds & depth cues</div>
<div id="err"></div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* ========= basic utils ========= */
const rad = THREE.MathUtils.degToRad;
const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
function mulberry32(seed){ let t=seed>>>0; return ()=>{ t+=0x6D2B79F5; let r=Math.imul(t^(t>>>15),1|t); r^=r+Math.imul(r^(r>>>7),61|r); return ((r^(r>>>14))>>>0)/4294967296; }; }
const smooth=(t)=>t*t*(3-2*t);
function makeNoise2D(seed) {
  const s = seed | 0;
  function hash(i, j) {
    let h = ((i|0) * 374761393) ^ ((j|0) * 668265263) ^ (s * 362437);
    h = (h ^ (h >>> 13)) >>> 0;
    h = (h * 1274126177) >>> 0;
    return h / 4294967295;
  }
  return (x, z) => {
    const ix = Math.floor(x), iz = Math.floor(z);
    const fx = x - ix, fz = z - iz;
    const u = smooth(fx), v = smooth(fz);
    const n00 = hash(ix, iz),     n10 = hash(ix + 1, iz);
    const n01 = hash(ix, iz + 1), n11 = hash(ix + 1, iz + 1);
    const nx0 = n00 + (n10 - n00) * u;
    const nx1 = n01 + (n11 - n01) * u;
    return nx0 + (nx1 - nx0) * v; // 0..1
  };
}
function makeFBM(noise){ 
  return (x,z,oct=5,pers=0.5,lacun=2)=>{ 
    let f=1,a=1,acc=0,sum=0;
    for(let o=0;o<oct;o++){ acc+=a*noise(x*f,z*f); sum+=a; f*=lacun; a*=pers; }
    return acc/sum;
  };
}
function ridged(n){ return 1 - Math.abs(2*n - 1); }

/* ========= error helper ========= */
const errBox = document.getElementById('err');
function showError(e){
  errBox.style.display='block';
  errBox.textContent = (typeof e === 'string') ? e : (e?.message || String(e));
  console.error(e);
}
window.addEventListener('error', e=>showError(e.error||e.message));
window.addEventListener('unhandledrejection', e=>showError(e.reason||e));

/* ========= DOM refs ========= */
const app = document.getElementById('app');
const uiScore = document.getElementById('uiScore');
const uiMult  = document.getElementById('uiMult');
const uiSpeed = document.getElementById('uiSpeed');
const uiAlt   = document.getElementById('uiAlt');
const uiSeed  = document.getElementById('uiSeed');
const uiDiff  = document.getElementById('uiDiff');
const uiQual  = document.getElementById('uiQual');
const crashEl = document.getElementById('crash');
const pausedEl= document.getElementById('paused');

/* ========= three setup ========= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(64, 1, 0.1, 35000);
camera.position.set(0, 1600, 4200);

const fogColor = new THREE.Color('#cfeaff');
scene.fog = new THREE.Fog(fogColor, 700, 26000);

const hemi = new THREE.HemisphereLight(0xcfeaff, 0xbfa17a, 0.95); hemi.position.set(0,1200,0); scene.add(hemi);
const dir  = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(-900,1600,1100); scene.add(dir);
const amb  = new THREE.AmbientLight(0xffffff, 0.22); scene.add(amb);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
app.appendChild(renderer.domElement);

/* ========= input ========= */
const inputs = { w:false,s:false,a:false,d:false,q:false,e:false };
function setKey(e, down){
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  switch(e.code){
    case 'KeyW': case 'ArrowUp':    inputs.w = down; break;
    case 'KeyS': case 'ArrowDown':  inputs.s = down; break;
    case 'KeyA': case 'ArrowLeft':  inputs.a = down; break;
    case 'KeyD': case 'ArrowRight': inputs.d = down; break;
    case 'KeyQ': inputs.q = down; break;
    case 'KeyE': inputs.e = down; break;
    case 'KeyP': if(down) togglePause(); break;
    case 'KeyR': if(down) restart(); break;
    case 'Digit1': if(down) { setQuality('high'); } break;
    case 'Digit2': if(down) { setQuality('ultra'); } break;
    case 'KeyN': if(down) { nextSeed(); } break;
  }
}
window.addEventListener('keydown', e=>setKey(e,true), {passive:false});
window.addEventListener('keyup',   e=>setKey(e,false), {passive:false});

/* ========= physics & player ========= */
const state = {
  playerPos: new THREE.Vector3(0,1600,4200),
  playerQuat: new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), rad(8)),
  playerRadius: 1,
  vel: new THREE.Vector3(0,-10,-50),

  // Arcade aero
  gravity: 9.0,
  qScale: 0.018,
  liftScale: 0.16,
  dragScale: 0.018,
  Cd0: 0.025,
  CdK: 0.035,
  ClMax: 1.6,
  aoaLimit: rad(32),
  sideSlipDamp: 1.3,
  alignStability: 0.35,
  thrustArcade: 6.0,
  groundEffectH: 140,
  groundEffectStrength: 0.8,

  maxSpeed: 175,

  yawRate:   rad(95),
  pitchRate: rad(75),
  rollRate:  rad(150),

  score:0, multiplier:1, maxMultiplier:12, proxThreshold:14,
  crashed:false, paused:false,
  worldSeed: Math.floor(Math.random()*1e9), difficulty:1, highScore:0,
};

let quality = 'high'; // default STABLE; toggle 'ultra' with 2
uiQual.textContent = 'High';

/* ========= glider (slightly bigger) + shadow ========= */
function buildGlider(){
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.ConeGeometry(0.7,2.4,6), new THREE.MeshStandardMaterial({color:0xffffff, roughness:.4, metalness:.1}));
  body.rotation.x = Math.PI/2; g.add(body);
  const wing = new THREE.Mesh(new THREE.BoxGeometry(4.2,.10,.7), new THREE.MeshStandardMaterial({color:0x87ceeb, roughness:.6}));
  wing.position.set(0,0,-.1); g.add(wing);
  const tail = new THREE.Mesh(new THREE.BoxGeometry(1.2,.08,.6), new THREE.MeshStandardMaterial({color:0x87ceeb, roughness:.6}));
  tail.position.set(0,-.25,.5); tail.rotation.z = rad(15); g.add(tail);
  return g;
}
const glider = buildGlider(); scene.add(glider);

function makeShadowTexture(){
  const s=64, cnv=document.createElement('canvas'); cnv.width=cnv.height=s;
  const ctx=cnv.getContext('2d'); const g=ctx.createRadialGradient(s/2,s/2,8, s/2,s/2,s/2);
  g.addColorStop(0,'rgba(0,0,0,0.35)'); g.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(s/2,s/2,s/2,0,Math.PI*2); ctx.fill();
  const tex=new THREE.CanvasTexture(cnv); tex.anisotropy=4; return tex;
}
const shadowSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeShadowTexture(), transparent:true, depthWrite:false, opacity:.8 }));
shadowSprite.renderOrder = -1; scene.add(shadowSprite);

/* ========= terrain (tiled LOD) ========= */
let terrain = null; // {group, params, heightAt, portal}
let portalMesh = null;

function makeCloudTexture(){
  const s=128, cnv=document.createElement('canvas'); cnv.width=cnv.height=s;
  const ctx=cnv.getContext('2d');
  const g=ctx.createRadialGradient(s/2,s/2,12, s/2,s/2,s/2);
  g.addColorStop(0,'rgba(255,255,255,0.9)');
  g.addColorStop(1,'rgba(255,255,255,0.0)');
  ctx.fillStyle=g; ctx.fillRect(0,0,s, s);
  const tex = new THREE.CanvasTexture(cnv); tex.anisotropy = 4; return tex;
}
function buildCloudLayer(seed, params){
  const tex = makeCloudTexture();
  const grp = new THREE.Group();
  const count = quality==='ultra' ? 220 : 160;
  for(let i=0;i<count;i++){
    const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false, opacity: 0.26 + Math.random()*0.34 }));
    sp.position.set((Math.random()-0.5)*params.width*1.2, 1700 + (Math.random()-0.5)*120, (Math.random()-0.30)*params.length);
    const s = (quality==='ultra' ? 140 : 120) + Math.random()*180;
    sp.scale.set(s, s, 1);
    grp.add(sp);
  }
  return grp;
}

function makeHeightFn(seed, params){
  const noise = makeNoise2D(seed ^ 0x9e3779b9);
  const fbm   = makeFBM(noise);
  const nx=params.nx, nz=params.nz;
  return (x,z)=>{
    const n1 = fbm(x*nx, z*nz, 7, 0.55, 2.05);
    const n2 = ridged(fbm(x*nx*0.6, z*nz*0.6, 6, 0.5, 2.0));
    const n3 = fbm(x*nx*5.0, z*nz*5.0, 3, 0.5, 2.0);
    const base = (1-params.ridgeMix)*n1 + params.ridgeMix*n2;
    const peaky = 1 - Math.pow(1 - base, params.peakSharp);
    const shaped = clamp(peaky + (n3-0.5)*params.microAmp, 0, 1);
    const slopeTerm = (-(z + params.length*0.30) / params.length) * params.slope * params.amp;
    return params.base + shaped*params.amp + slopeTerm;
  };
}

function buildTerrain(seed){
  const isUltra = quality==='ultra';
  // LOD settings: keep Ultra heavy but under ~700k verts
  const params = isUltra ? {
    width:  6400, length: 24000,
    amp: 2600, base: -140, slope: 0.02,
    nx: 0.0012, nz: 0.0012, ridgeMix: 0.82, microAmp: 0.18, peakSharp: 3.6,
    tilesX: 8, tilesZ: 20, tileSeg: 64,   // ≈ 65^2 * 160 = ~676k verts
  } : {
    width:  4200, length: 16000,
    amp: 1500, base: -120, slope: 0.02,
    nx: 0.0013, nz: 0.0013, ridgeMix: 0.78, microAmp: 0.16, peakSharp: 2.1,
    tilesX: 6, tilesZ: 14, tileSeg: 48,   // ≈ 49^2 * 84 = ~201k verts
  };

  const heightAt = makeHeightFn(seed, params);

  const group = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({ vertexColors:true, flatShading:false, roughness:0.95, metalness:0.02 });

  const startX = -params.width/2, startZ = -params.length/2;
  const tileW = params.width / params.tilesX;
  const tileL = params.length / params.tilesZ;

  // build tiles (LOCAL coords for x/z; place tile by mesh.position → better culling)
  for (let tz=0; tz<params.tilesZ; tz++){
    for (let tx=0; tx<params.tilesX; tx++){
      const geo = new THREE.PlaneGeometry(tileW, tileL, params.tileSeg, params.tileSeg);
      geo.rotateX(-Math.PI/2);
      const pos = geo.attributes.position;
      const vcount = pos.count;
      const colors = new Float32Array(vcount*3);

      const ox = startX + tileW*(tx+0.5);
      const oz = startZ + tileL*(tz+0.5);

      let i=0;
      for(let v=0; v<vcount; v++){
        const lx = pos.getX(v), lz = pos.getZ(v);
        const wx = ox + lx, wz = oz + lz;
        const y = heightAt(wx,wz);
        pos.setY(v, y);

        // color by altitude + subtle contour
        const t = clamp((y - (params.base-140)) / (params.amp+600), 0, 1);
        const rockLo = new THREE.Color('#cda077');
        const rockHi = new THREE.Color('#8d6442');
        const grass  = new THREE.Color('#9ecb7a');
        const snow   = new THREE.Color('#f5f7fb');
        const c = new THREE.Color();
        if (t < 0.45) c.lerpColors(rockLo, rockHi, t/0.45);
        else if (t < 0.80) c.lerpColors(rockHi, grass, (t-0.45)/0.35);
        else c.lerpColors(grass, snow, (t-0.80)/0.20);
        const band = ((Math.floor((y+120)/60)%2) ? 0.95 : 1.05);
        c.multiplyScalar(band);
        colors[i++]=c.r; colors[i++]=c.g; colors[i++]=c.b;
      }
      geo.setAttribute('color', new THREE.BufferAttribute(colors,3));
      geo.computeVertexNormals();

      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(ox, 0, oz); // << keep local vertices; place tile by transform
      group.add(mesh);
    }
  }

  // clouds
  const cloudGroup = buildCloudLayer(seed, params); group.add(cloudGroup);

  // portal near far end (optional)
  const portalZ = -params.length/2 + 240;
  const portalY = heightAt(0, portalZ) + (isUltra? 90 : 80);
  const ringR= isUltra? 24 : 22, ringT= isUltra? 2.8 : 2.6;
  const portalMat = new THREE.MeshStandardMaterial({ color: 0x7aa2ff, emissive: new THREE.Color(0x7aa2ff).multiplyScalar(.6), roughness:.2, metalness:0.0 });
  const portalMeshLocal = new THREE.Mesh(new THREE.TorusGeometry(ringR, ringT, 18, 72), portalMat);
  portalMeshLocal.position.set(0, portalY, portalZ);
  portalMeshLocal.userData.center = portalMeshLocal.position.clone();
  portalMeshLocal.userData.ringR = ringR;
  portalMeshLocal.userData.thickness = ringT;
  group.add(portalMeshLocal);

  scene.add(group);
  return { group, params, heightAt, portal: portalMeshLocal };
}

function terrainHeightAt(x,z){ return terrain.heightAt(x,z); }
function terrainNormalAt(x,z){
  const e=6, hL=terrainHeightAt(x-e,z), hR=terrainHeightAt(x+e,z), hD=terrainHeightAt(x,z-e), hU=terrainHeightAt(x,z+e);
  const n = new THREE.Vector3(-(hR-hL)/(2*e), 1, -(hU-hD)/(2*e)); return n.normalize();
}

/* ========= world mgmt ========= */
function disposeWorld(){
  if (!terrain) return;
  scene.remove(terrain.group);
  terrain.group.traverse(o=>{ 
    if (o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); }
    if (o.isSprite){ o.material?.map?.dispose?.(); o.material?.dispose?.(); }
  });
  portalMesh = null;
  terrain = null;
}

function generateWorld(seed){
  const start = performance.now();
  disposeWorld();
  terrain = buildTerrain(seed);
  portalMesh = terrain.portal;
  uiSeed.textContent = seed;

  // start high above actual ground at spawn Z
  const startZ = terrain.params.length * 0.42;
  const startY = terrainHeightAt(0, startZ) + 420; // safe separation
  state.playerPos.set(0, startY, startZ);
  state.playerQuat.identity().multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), rad(8)));
  const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(state.playerQuat).normalize();
  state.vel.copy(fwd).multiplyScalar(65); state.vel.y -= 6;

  const t = performance.now() - start;
  // if Ultra was too slow, auto-fallback to High
  if (quality==='ultra' && t > 2500){
    showError(`Ultra build took ${t.toFixed(0)}ms → switching to High for stability`);
    setQuality('high');
  }
}

function setQuality(q){
  quality = q;
  uiQual.textContent = (q==='ultra') ? 'Ultra (10×)' : 'High';
  generateWorld(state.worldSeed);
}
function nextSeed(){
  state.worldSeed = (state.worldSeed * 1664525 + 1013904223) >>> 0;
  state.difficulty += 1;
  generateWorld(state.worldSeed);
}

/* ========= pause/restart ========= */
function togglePause(){ state.paused=!state.paused; pausedEl.style.display = state.paused ? 'grid' : 'none'; }
function doCrash(){ state.crashed=true; crashEl.style.display='grid'; state.highScore = Math.max(state.highScore, state.score|0); document.getElementById('uiHi').textContent = state.highScore.toFixed(0); }
function restart(){
  const startZ = terrain ? terrain.params.length * 0.42 : 4200;
  const startY = terrain ? terrainHeightAt(0, startZ) + 420 : 1600;
  state.playerPos.set(0, startY, startZ);
  state.playerQuat.identity().multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), rad(8)));
  const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(state.playerQuat).normalize();
  state.vel.copy(fwd).multiplyScalar(65); state.vel.y -= 6;
  state.score=0; state.multiplier=1; state.crashed=false;
  crashEl.style.display='none';
}

/* ========= layout ========= */
function resize(){ const w=window.innerWidth, h=window.innerHeight; renderer.setSize(w,h); camera.aspect=w/h; camera.updateProjectionMatrix(); }
window.addEventListener('resize', resize); resize();

/* ========= boot ========= */
generateWorld(state.worldSeed);

/* ========= loop: arcade aircraft physics ========= */
function terrainDistanceBelow(pos){ return pos.y - terrainHeightAt(pos.x, pos.z); }

const clock = new THREE.Clock();
renderer.setAnimationLoop(()=>{
  const dt = Math.min(0.033, clock.getDelta());
  if (state.paused || state.crashed){ renderer.render(scene,camera); return; }

  // controls → orientation
  const yaw   = ((inputs.a?1:0) - (inputs.d?1:0)) * state.yawRate   * dt;
  const pitch = ((inputs.s?1:0) - (inputs.w?1:0)) * state.pitchRate * dt;
  const roll  = ((inputs.q?1:0) - (inputs.e?1:0)) * state.rollRate  * dt;
  const qYaw   = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),  yaw);
  const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),  pitch);
  const qRoll  = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -roll);
  state.playerQuat.multiply(qYaw).multiply(qPitch).multiply(qRoll).normalize();

  // body axes
  const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(state.playerQuat).normalize();
  const up  = new THREE.Vector3(0,1,0).applyQuaternion(state.playerQuat).normalize();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(state.playerQuat).normalize();

  // airflow & coefficients
  const spd = state.vel.length();
  const air = spd>1e-4 ? state.vel.clone().multiplyScalar(-1/spd) : fwd.clone().multiplyScalar(-1);
  const f = fwd.dot(air), u = up.dot(air), r = right.dot(air);
  let aoa  = clamp(Math.atan2(u, f), -state.aoaLimit, state.aoaLimit);
  const beta = Math.atan2(r, f);
  const Cl = state.ClMax * Math.sin(2*aoa);
  const Cd = state.Cd0 + state.CdK*(Cl*Cl) + 0.02*(beta*beta);
  const q   = (spd*spd) * state.qScale;

  // directions
  let liftDir = up.clone().sub(air.clone().multiplyScalar(up.dot(air))); const ll = liftDir.length(); if (ll<1e-5) liftDir.copy(up); else liftDir.multiplyScalar(1/ll);
  let sideDir = right.clone().sub(air.clone().multiplyScalar(right.dot(air))); const sl = sideDir.length(); if (sl<1e-5) sideDir.copy(right); else sideDir.multiplyScalar(1/sl);
  const dragDir = spd>1e-4 ? state.vel.clone().multiplyScalar(-1/spd) : fwd.clone().multiplyScalar(-1);

  // ground effect boost
  const alt = terrainDistanceBelow(state.playerPos);
  const gNorm = terrainNormalAt(state.playerPos.x, state.playerPos.z);
  const parallelFactor = 1 - Math.abs(fwd.dot(gNorm));
  const geAlt = clamp(1 - alt / state.groundEffectH, 0, 1);
  const groundEffect = 1 + state.groundEffectStrength * geAlt * Math.pow(parallelFactor, 1.2);

  // forces
  const gravity = new THREE.Vector3(0, -state.gravity, 0);
  const lift    = liftDir.multiplyScalar(q * Cl * state.liftScale * groundEffect);
  const drag    = dragDir.multiplyScalar(q * Cd * state.dragScale);
  const sideDamp= sideDir.multiplyScalar(-q * state.sideSlipDamp * beta);
  const thrust  = fwd.clone().multiplyScalar(state.thrustArcade);

  // alignment damping (arcade stabilizer)
  const vBody = state.vel.clone().applyQuaternion(state.playerQuat.clone().invert());
  const alignBody = new THREE.Vector3(-vBody.x, -vBody.y*0.6, 0).multiplyScalar(state.alignStability);
  const alignWorld = alignBody.applyQuaternion(state.playerQuat);

  // integrate
  state.vel.addScaledVector(gravity, dt);
  state.vel.addScaledVector(lift, dt);
  state.vel.addScaledVector(drag, dt);
  state.vel.addScaledVector(sideDamp, dt);
  state.vel.addScaledVector(thrust, dt);
  state.vel.addScaledVector(alignWorld, dt);

  // clamp speed
  const spdNew = state.vel.length();
  if (spdNew > state.maxSpeed) state.vel.multiplyScalar(state.maxSpeed/spdNew);

  // position
  state.playerPos.addScaledVector(state.vel, dt);

  // camera
  const camOffLocal = new THREE.Vector3(0, 4.5, 17.0);
  const camPos = camOffLocal.clone().applyQuaternion(state.playerQuat).add(state.playerPos);
  camera.position.lerp(camPos, 0.16);
  camera.lookAt(state.playerPos.clone().add(fwd.clone().multiplyScalar(32)));

  // glider
  glider.position.copy(state.playerPos);
  glider.quaternion.copy(state.playerQuat);

  // ground collision
  const distBelow = alt;
  const nearestDist = distBelow - state.playerRadius;
  if (nearestDist < 0){ doCrash(); renderer.render(scene,camera); return; }

  // shadow marker
  const yGround = state.playerPos.y - distBelow;
  const shadowSize = clamp(30 + distBelow*0.12, 30, 520);
  const shadowAlpha = clamp(0.85 - distBelow/1400, 0.12, 0.85);
  shadowSprite.position.set(state.playerPos.x, yGround + 0.2, state.playerPos.z);
  shadowSprite.scale.set(shadowSize, shadowSize, 1);
  shadowSprite.material.opacity = shadowAlpha;

  // portal
  if (portalMesh){
    const c = portalMesh.userData.center, ringR=portalMesh.userData.ringR, thick=portalMesh.userData.thickness;
    const dx=state.playerPos.x-c.x, dz=state.playerPos.z-c.z, dy=Math.abs(state.playerPos.y-c.y);
    const radial=Math.hypot(dx,dz);
    if (Math.abs(radial - ringR) < thick*0.7 && dy < thick*0.9) nextSeed();
  }

  // HUD
  const closeness = clamp(1 - (nearestDist / state.proxThreshold), 0, 1);
  const gain = (4 + spdNew * 0.16) * state.multiplier * (0.25 + closeness * 1.4);
  state.score += gain * dt;
  if (closeness > 0.15) state.multiplier = Math.min(state.maxMultiplier, state.multiplier + dt * (0.15 + closeness * 0.45));
  else state.multiplier = Math.max(1, state.multiplier - dt * 1.0);

  uiScore.textContent = state.score.toFixed(0);
  uiMult.textContent  = state.multiplier.toFixed(1);
  uiSpeed.textContent = spdNew.toFixed(1);
  uiAlt.textContent   = distBelow.toFixed(0);
  uiSeed.textContent  = state.worldSeed;
  uiDiff.textContent  = state.difficulty;

  renderer.render(scene, camera);
});
</script>
</body>
</html>

